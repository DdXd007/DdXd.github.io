# 数据结构：树状数组

![](E:\笔记\数据结构：树状数组\树状数组.png)

树状数组是一种针对区间数据处理而产生的数据结构，具有优秀的空间复杂度(O(n))，优秀的修改单点数值和查询区间和的时间复杂度（O(logn)）

## 支持的操作

### 1、单点修改（O（logn））

单点修改数组后不需要重新遍历数组维护结构性质，只需要沿着修改单点所在的支树向上修改，最坏时间复杂度为**O(logn);**

### 2、区间和查询（O（logn））

树状数组和前缀和数组相似，是通过分别计算从1到区间右限的和与1到区间左限的和，再做差得到结果。在树状数组中计算前 k 个数之和的时间复杂度为**O（logn）**

故查询区间和的时间复杂度为**O（logn）**

### 3、通过差分的思想，进行区间修改，单点查询

只需要构造出原数组的差分序列，再通过树状数组维护其前缀和，即可实现区间修改和单点查询

***区间修改和区间查询的功能在树状数组中难以实现，可以通过线段树实现。***



## lowbit（x）操作

`lowbit（x）`被用来计算x的二进制表达中**最低的1和后面的0构成的数字**

根据计算机的特性通过 `x & （-x）`计算,即：

`lowbit(x) = x & (-x)`



![](E:\笔记\数据结构：树状数组\20210703105626218.png)

发现规律每个索引的**lowbit**对应该位置记录加和元素的个数。



## 代码部分

### 1、单点修改

在进行单点修改时只需要维护修改点的父节点的性质即可

```c++
void add(int p, int k) {
	while(p <= n) {
        t[p] += k;
        p += lowbit(p);
    }
}
```

数组数组的初始化是通过n次的add操作实现的。

### 2、区间查询

按照下图逻辑进行求和查询

![](E:\笔记\数据结构：树状数组\20210703111100776.png)

```c++
int sum(int p) {
	int ret = 0;
	while(p > 0) {
		ret += t[p];
		p -= lowbit(p);
	}
    return ret;
}
```

-------------

### 3、差分序列的区间修改

树状数组的区间修改原理和上文提到的单点修改类似，通过修改差分序列的单点数值，即可实现原序列的区间修改。

### 4、差分序列的单点查询

类似的差分序列的单点查询与上文的区间查询类似，通过相同的累加方式就能在O（logn）的时间复杂度内计算出单点的数值；



# 题目



# 【模板】树状数组 1

## 题目描述

如题，已知一个数列，你需要进行下面两种操作：

- 将某一个数加上 $x$

- 求出某区间每一个数的和

## 输入格式

第一行包含两个正整数 $n,m$，分别表示该数列数字的个数和操作的总个数。   

第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。

接下来 $m$ 行每行包含 $3$ 个整数，表示一个操作，具体如下：

- `1 x k`  含义：将第 $x$ 个数加上 $k$

- `2 x y`  含义：输出区间 $[x,y]$ 内每个数的和

## 输出格式

输出包含若干行整数，即为所有操作 $2$ 的结果。

## 样例 #1

### 样例输入 #1

```
5 5
1 5 4 2 3
1 1 3
2 2 5
1 3 -1
1 4 2
2 1 4
```

### 样例输出 #1

```
14
16
```

## 提示

【数据范围】

对于 $30\%$ 的数据，$1 \le n \le 8$，$1\le m \le 10$；   
对于 $70\%$ 的数据，$1\le n,m \le 10^4$；   
对于 $100\%$ 的数据，$1\le n,m \le 5\times 10^5$。

数据保证对于任意时刻，$a$ 的任意子区间（包括长度为 $1$ 和 $n$ 的子区间）和均在 $[-2^{31}, 2^{31})$ 范围内。


样例说明：

 ![](https://cdn.luogu.com.cn/upload/pic/2256.png) 

故输出结果14、16

```c++
#include <bits/stdc++.h>

using namespace std;

const int maxn = 5e5 + 10;

int lowbit(int x) {
    return x & (-x);
}
vector<int> a(maxn, 0);

void add(int pos, int val) {
    int p = pos;
    while(p < maxn) {
        a[p] += val;
        p += lowbit(p);
    }
}

int find(int pos) {
    int p = pos;
    int ret = 0;
    while(p >= 1) {
        ret += a[p];
        p -= lowbit(p);
    }
    return ret;
}

int main() {
    int n, m; cin >> n >> m;
    for(int i = 1; i <= n; i++) {
        int tmp; cin >> tmp;
        add(i, tmp);
    }

    while(m--) {
        int u, v, w;
        cin >> u >> v >> w;
        if(u == 1) {
            add(v, w);
        }
        else {
            cout << (find(w) - find(v - 1)) << endl;
        }
    }

    return 0;
}
```





# 【模板】树状数组 2

## 题目描述

如题，已知一个数列，你需要进行下面两种操作：

1. 将某区间每一个数加上 $x$；

2. 求出某一个数的值。

## 输入格式

第一行包含两个整数 $N$、$M$，分别表示该数列数字的个数和操作的总个数。

第二行包含 $N$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i $ 项的初始值。

接下来 $M$ 行每行包含 $2$ 或 $4$个整数，表示一个操作，具体如下：

操作 $1$： 格式：`1 x y k` 含义：将区间 $[x,y]$ 内每个数加上 $k$；

操作 $2$： 格式：`2 x` 含义：输出第 $x$ 个数的值。

## 输出格式

输出包含若干行整数，即为所有操作 $2$ 的结果。

## 样例 #1

### 样例输入 #1

```
5 5
1 5 4 2 3
1 2 4 2
2 3
1 1 5 -1
1 3 5 7
2 4
```

### 样例输出 #1

```
6
10
```

## 提示

#### 样例 1 解释：

 ![](https://cdn.luogu.com.cn/upload/pic/2258.png) 

故输出结果为 6、10。

---

#### 数据规模与约定

对于 $30\%$ 的数据：$N\le8$，$M\le10$；

对于 $70\%$ 的数据：$N\le 10000$，$M\le10000$；

对于 $100\%$ 的数据：$1 \leq N, M\le 500000$，$1 \leq x, y \leq n$，保证任意时刻序列中任意元素的绝对值都不大于 $2^{30}$。



```c++
#include <bits/stdc++.h>

using namespace std;

const int maxn = 5e5 + 10;

int lowbit(int x) {
    return x & (-x);
}
vector<int> a(maxn, 0);

void add(int pos, int val) {
    int p = pos;
    while(p < maxn) {
        a[p] += val;
        p += lowbit(p);
    }
}

int find(int pos) {
    int p = pos;
    int ret = 0;
    while(p >= 1) {
        ret += a[p];
        p -= lowbit(p);
    }
    return ret;
}

int main() {
    int n, m; cin >> n >> m;
    int pre = 0;
    for(int i = 1; i <= n; i++) {
        int tmp; cin >> tmp;
        add(i, tmp - pre);
        pre = tmp;

    }

    while(m--) {
        int op; cin >> op;
        if(op == 1) {
            int x, y, k;
            cin >> x >> y >> k;
            add(x, k);
            add(y + 1, -k);
        }
        else {
            int x; cin >> x;
            cout << find(x) << endl;
        }
    }

    return 0;
}
```